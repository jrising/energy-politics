function [strat_1, strat_2, VV2_1, VV2_2] = optimize_nolimit(N, S, C, D_C_min, D_C_max, D, P_f_min, P_f_max, F, ...
                                                  Q_const, lambdas,  ideals, discounts, util_type, ...
                                                  termlen, polModel, voteModel, vmArgs, estrat, prefstrats, sigma, process)
% N = number of monte carlo projections
%   no used for coghi
% strat_* are SxCxF matrices; values are campaigned clean shares
%   S = planning horizon (timesteps)
%   C is discretized version of the clean energy share
%   F is discretized versions of P_f
% values are 1 (no change), 2-D+1 (change in share on next period)


strat_1 = zeros(S-1, C, F);
strat_2 = zeros(S-1, C, F);

% VV is a Cx2F matrix

P_f = linspace(P_f_min, P_f_max, F);
S_C = linspace(0, 1, C);

% STEP 1: Calculate V[S] under every scenario
% VV is CxFx2 states of world x 2 perspectives
%VV2_1 = repmat(payoff(S_C', lambdas(1), ideals(1), 1), [1 F 2]);
%VV2_2 = repmat(payoff(S_C', lambdas(2), ideals(2), 1), [1 F 2]);
VV2_1 = repmat(0, [C F 2]);
VV2_2 = repmat(0, [C F 2]);

% STEP 2: Determine optimal action in t = S-1 and back
[state1, state2a, state2b, xprob2, q_c, q_f] = make_actions(C, D_C_min, ...
                                                  D_C_max, D, Q_const);

dc = [0 linspace(D_C_min, D_C_max, D)/C];

for t = (S-1):-1:1
  disp(t);
  is_election = mod(t, termlen) == 0;
  eactions = squeeze(estrat(t, state1, :));  % retrieves the best economic state for each of the 20 states (as indices).
  if ~isnan(prefstrats)
    prefactions = squeeze(prefstrats(t, state1, :, :));
  else
    prefactions = nan;
  end

  if polModel == 'retro'
    [VV2_1, VV2_2, strat_1(t, :, :), strat_2(t, :, :)] ...
        = optimize_step_retro(VV2_1, VV2_2, N, C, D_C_min, D_C_max , P_f_min, P_f_max, ...
                              F,  state1, state2a, ...
                                state2b, xprob2, dc, q_c, q_f, ...
                              Q_const, lambdas, ideals, discounts, util_type, ...
                              voteModel * is_election, vmArgs, eactions, prefactions, sigma,...
                              process);
  elseif polModel == 'retex'
    [VV2_1, VV2_2, strat_1(t, :, :), strat_2(t, :, :)] ...
        = optimize_step_retex(VV2_1, VV2_2, N, C, D_C_min, D_C_max, P_f_min, P_f_max, ...
                               F, state1, state2a, state2b, xprob2, dc, q_c, q_f, ...
                               Q_const, lambdas, ideals, discounts, util_type, ...
                               voteModel * is_election, vmArgs, eactions, prefactions, sigma,...
                               process);
  elseif polModel == 'coghi'
    [VV2_1, VV2_2, strat_1(t, :, :), strat_2(t, :, :)] ...
        = optimize_step_coghi(VV2_1, VV2_2, C, D_C_min, D_C_max,P_f_min, P_f_max, ...
                              F, state1, state2a, state2b, xprob2, dc, q_c,  ...
                              Q_const, lambdas, ideals, discounts, util_type, ...
                              voteModel * is_election, vmArgs, eactions,prefactions,  2 * is_election);
  elseif polModel == 'baser'
    [VV2_1, VV2_2, strat_1(t, :, :), strat_2(t, :, :)] ...
        = optimize_step_baser(VV2_1, VV2_2, N, C, D_C_min, D_C_max,P_f_min, P_f_max, ...
                              F, state1, state2a, state2b, xprob2, dc, q_c, q_f, ...
                              Q_const, lambdas, ideals, discounts, util_type, ...
                              voteModel * is_election, vmArgs, eactions, ...
                              process);
  else
    error('Unknown political model');
  end
end
